\documentclass[]{article}

\usepackage{geometry}
\usepackage{marginnote}


% Copyright
%\setcopyright{usgovmixed}

% DOI
%\acmDOI{}

% ISBN
%\acmISBN{}

% Conference
%cmConference[VPA17]{Fourth International Workshop on Visual Performance Analysis}{November 2017}{Denver, Colorado USA}
%\acmYear{2017}
%\copyrightyear{2017}

\begin{document}

\title{The Hybrid Task Graph Scheduler Code Generator}

\author{Timothy Blattner \and Alejandro Vega-Nogales}



%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
%\begin{CCSXML}
%\end{CCSXML}

%\ccsdesc[]{}

%\keywords{}

\maketitle

\begin{abstract}
The objective of this research is to develop a tool for creating a task graph within a graphical user interface and generating the boiler-plate code associated with executing the graph using the Hybrid Task Graph Scheduler.
\end{abstract}

\section{Introduction}

The Hybrid Task Graph Scheduler (HTGS) is an approach that aims at obtaining performance on systems with multiple CPUs and GPUs. There are three components to HTGS: (1) an abstract execution model, (2) a framework, and (3) an API. The abstract execution model is used to map  an algorithm into a task graph that executes the core computational kernels using coarse-grained parallelism. The HTGS framework provides functionality to build the task graph, which is made up a series of vertices and edges. A vertex represents a task, which can manage state or execute computation on data that is sent to the task. Edges connect these tasks to encode data dependencies. The HTGS API implements this framework.

\textbf{HTGS represents an algorithm's components explicitly as a task graph} and provides a separation of concerns between in-core compute kernels, orchestration, memory management, state maintenance, and data motion. This explicit representation enables users of HTGS to develop, profile, and debug algorithms at a higher level of abstraction.

The primary contribution of this study is a novel tool, to be used by NIST researchers/developers, that uses the explicit graph representation from HTGS and embeds it into a graphical user interface (GUI). Within the GUI, a developer can create new HTGS tasks, define input and output types, select task interface functions, and draw edges between tasks. The developer can then \emph{Export} the graph, which will generate the necessary code to compile and run the graph. This allows researchers/developers to operate at the graph representation, and not have to concern themselves with instrumenting the complex boiler-plate code that is associated with HTGS.

\section{HTGS Overview}

Developing an algoritm with HTGS requires four components; (1) Tasks, (2) Data, (3) Mandatory/optional interface functions, and (4) A main function to build the graph and interact with it. 


\begin{description}
\item[Tasks] \hfill \\
	A task in its simplest form consumes data that is sent from its input edge, processes that data, and then produces data onto its output edge. The input and output types are represented using templates, for example; $FooTask<T, U>$ defines $T$ and $U$ as the input and output data types of $FooTask$, respectively. A task can only have one output edge, but may have multiple input edges (except the bookkeeper, who can have multiple input edges and multiple output edges). If a task is connected via an edge, then the output of the producer task should match the input type of the consumer task.
	
	HTGS implements four complex tasks; CUDATask, Bookkeeper, MemoryManager, and ExecutionPipeline. Each complex task will have additional constraints beyond just a simple task.  For example, the Bookkeeper is responsible for managing complex data dependencies. The functionality for this task is defined by implementing rules. Each rule has its own input and output types (the input type matches the bookkeeper type), where the developer must define how/when the rule will produce data. These rules are typically accessed synchronously with a mutex lock, which will ensure only a single thread accesses each rule. 
	
    HTGS tasks use multi-threading to improve their data consumption rates. The number of threads associated with a task is passed to the constructor. This will cause the task to be copied, binding each copy to a separate thread.
	
\item[Data] \hfill \\	
	Data in HTGS is a class container that inherits the HTGS IData interface. The input and output types of all tasks are required to use the IData interface. These containers obtain contain pointers to data and fulfill parameter requirements for task kernels.
	
\item[Mandatory/optional interface functions] \hfill \\
	The HTGS task interface contains two mandatory and five optional interface (virtual) functions.
	
	\textbf{Mandatory Virtual Functions}
	\begin{itemize}
	\item $\mathrm{executeTask(data)}$
		\begin{itemize}
		\item The task will consume data and then call the $\mathrm{executeTask}$ function on that data. The programmer-implementation of $\mathrm{executeTask}$ defines the functionality of the task.
		\end{itemize}
	\item $\mathrm{copy()}$
		\begin{itemize}
		\item Defines how to copy the task and potentially share data between multiple instances of the task (used for multi-threading)
		\end{itemize}
	\end{itemize}

	\textbf{Optional Virtual Functions}
	\begin{itemize}
	\item $\mathrm{initialize()}$
		\begin{itemize}
		\item Called after a thread is bound to the task's instance (one instance per thread). Commonly used for binding the thread to a co-processor or allocating thread-local memory.
		\end{itemize}
	\item $\mathrm{shutdown()}$
		\begin{itemize}
		\item Called prior to termination of the thread that is bound to this task's instance. Commonly used to release any bindings to co-processors or deallocating thread-local memory.
		\end{itemize}	
	\item $\mathrm{getName()}$
		\begin{itemize}
		\item Gets the human-readable name of the task. Used to aid in task graph visualization.
		\end{itemize}		
	\item $\mathrm{executeTaskFinal()}$
		\begin{itemize}
		\item Called prior to shutdown by the last thread of the task. Commonly used for parallel reductions.
		\end{itemize}		
	\item $\mathrm{canTerminate(inputConnector)}$
		\begin{itemize}
		\item Called in the execution loop for each task. Used to customize the termination behavior of the task, such as when there is a cycle in the graph. By default the task will terminate when there is no longer any tasks producing data for the inputConnector (input queue).
		\end{itemize}		
	\end{itemize}

	Once a task has implemented the mandatory functions, then that task can be compiled and inserted into graphs. The optional functions allow for further customization to support a wide variety of architectures and algorithms.

\item[Main Function] \hfill \\
	The main function is used to allocate instances of the tasks, build the HTGS task graph, launch the graph, produce data for the graph, consume data from the output of a graph, wait for the graph to complete, and release graph memory. Each HTGS graph can have an input type and output type. The input of the graph can be bound to any task to consume data that is produced for the graph. Likewise, the output of the graph can be bound to multiple tasks to send produce data for the graph.
	
\end{description}


\section{HTGS Generator Overview}

As shown in the previous section, implementing an algorithm in HTGS requires a significant amount of boiler-plate code. The HTGS generator will be instrumental in improving productivity with implementing algorithms into HTGS task graphs. The generator features two components; (1) the Graphical User Interface (GUI) and (2) the code generator.


\subsection{Graphical User Interface}

The GUI is designed with an emphasis on ease of portability, such that the generator application can be deployed on a wide range of Operating Systems and devices. For ease of development, this aspect will be up for discussion to identify the optimal framework for developing the GUI, such as using C/C++, JavaScript, Java, Python, or ... etc. The GUI consists of a main window and a tool bar. 

\begin{description}
\item[Main Window] \hfill \\
	The main window contains the graph visualization that features the nodes and edges of the graph. The user can pan, zoom, and interact with components in the main window such as add new nodes, delete nodes, move nodes, draw edges, edit node meta-data, and edit edge meta-data. The meta-data for each node contains options for specifying input/output data types, selecting virtual functions, and an advanced section for complex tasks. The edges are only interactive for complex tasks such as memory managers and bookkeeper edges. 
	
	The main window must have error handling built-in to validate graph configurations and report incompatible tasks/edges. This will assist in preventing errors that may come up during code generation.


\item[Tool Bar] \hfill \\
	The tool bar holds onto easy-to-access objects that can be placed in the main window. Useful objects include defining data that are dragged and dropped into the input/output edges for each task. This will ensure data is well-defined and used appropriately to match the produce/consumer types between tasks. Additional tools can be added in this sidebar to select various basic or complex tasks. In the future, we plan on using this as a mechanism for building entire programs by adding pre-built task implementations.

\end{description}

Both of these components are easily extendable to developers to incorporate new attributes. \footnote{One important feature to keep in mind is the ability to export a graph representation into a textual format, such as JSON, that can be used to describe the functional components that are created during code generation. The general idea is to have a mechanism to adapt an existing graph by importing that graph into the GUI, modify it, and then update the code with the new components.} A generate button exports the code associated with the graph. \footnote{To simplify generation of code, data structures should be put in place that describe the components of the graph from the GUI and enable iterating through them programatically.}


\subsection{Code Generator}

The code generator iterates through the graph representation that was created from the GUI and generate a compressed C\texttt{++} project. For each data object, there is a subsequent header that is named based on the user-defined data name. This header file contains a class that inherits the HTGS IData object. For each node, a header and source file is generated with the specified name of the node. The header file contains the class interface function definitions that inherits the HTGS ITask with template types that match the user defined input/output types. The meta-data for each task determines which functions that will be added for the class. The source file contains the boiler-plate function implementations. For complex tasks, a header and source file is created based on the necessary parameters. For example, each edge coming out of a Bookkeeper generates a header and source file with the boiler-plate rule implementation. Each of these components are distributed in a directory structure for tasks, data, and rules. In the root directory there is a \emph{main} file that constructs the graph object, creates instances of all the tasks, and adds edges between the tasks. A rudimentary HTGS runtime is also defined. Lastly, a \emph{CMakeLists.txt} file is generated to enable compilation and execution of the project. The GUI presents these components as a compressed zip file, which can be downloaded.


\section{Tentative Implementation Plan}

\begin{enumerate}
  \item Identify optimal language and library to build the GUI
	\begin{itemize}
    \item Must be deployable across multiple platforms and Operating Systems
    \item Extendable to include new functionality
    \end{itemize}
  \item Create basic Graphical User Interface
    \begin{itemize}
    \item Basic tool bar implementation
      \begin{itemize}
      \item Select create node
      \item Select create edges
      \end{itemize}
    \item Basic Main Window implementation
      \begin{itemize}
      \item Pan and zoom
      \item Create nodes
      \item Select nodes
      \item Select edges
      \item Move nodes
      \item Draw edges
      \item Basic meta-data per node
      \item Basic meta-data per edge
      \item Delete nodes
      \item Delete edges
      \end{itemize}
    \end{itemize}
  \item Graphical User Interface Pre-Alpha
    \begin{itemize}
	\item Integration of HTGS specifications
	  \begin{itemize}
	  \item Data
	  	\begin{itemize}
	  	\item Create, Edit, Delete
	  	\item Ability to select data from tool bar
	  	\item Drag and drop data onto tasks to update input/output queues
	  	\end{itemize}
	  \item Tasks (nodes)
	  	\begin{itemize}
	  	\item Display and represent input/output types clearly
	  	\item Support drag and drop updating of input/output data types
	  	\item Right click view meta-data for tasks
	  	\item Check box options in meta-data to add/remove functions
	  	\end{itemize}	
	  \item Edges
	    \begin{itemize}
	    \item Drawing edges checks input/output types to ensure they match
	    \item Color edges red or report errors if invalid edges drawn (incompatible types)
	    \item Limit one output edge per task (Except Bookkeeper), but multiple input edges
	    \end{itemize}	
	  \end{itemize}
  \end{itemize}
  \item Code Generator Pre-Alpha
  	\begin{itemize}
  	\item Export function
  		\begin{itemize}
  		\item Generate code for each task and data
  		\item Generate code for main function connecting tasks
  		\item Generate CMakeLists.txt for compilation
  		\item Compress into zip for download
  		\end{itemize}	
  	\end{itemize}
  \item Graphical User Interface Alpha
  	\begin{itemize}
  	\item Simple developer interface to add new types of tasks
      \begin{itemize}
      \item Support adding complex tasks
	  \item Methods for customizing meta-data
	  \item Methods for generalizing rules for task edges
	  	\begin{itemize}
	  	\item Support for Bookkeeper rule edges
	  	\end{itemize}
	  \end{itemize}
  	\end{itemize}
  \item Code Generator Alpha
  	\begin{itemize}
  	\item Incorporate code generator into developer interface 
		\begin{itemize}
		\item Code generation customization
  		  \begin{itemize}
  		  \item Tasks
		  \item Data
		  \item New items (Rules)
		  \item Insertion into main
		  \item Insertion into CMakeLists.txt (dependencies)
		  \end{itemize}		
		\end{itemize}
  	\end{itemize}		
  \item Graphical User Interface and Code Generation Beta
    \begin{itemize}
    \item Support pre-built tasks
      \begin{itemize}
      \item Method for downloading the pre-built task
      \item Importing necessary data objects
      \end{itemize}
    \item Import/Export graph representation
      \begin{itemize}
      \item Export describes the graph in a textual way
      \item Import parses the textual representation into the GUI
	  \item Edit previously created graphs within GUI
	  \item Generate patch to be applied to existing graph source code	
      \end{itemize}  
    \end{itemize}
  \item Release v1.0

\end{enumerate}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography.bib}

\end{document}
